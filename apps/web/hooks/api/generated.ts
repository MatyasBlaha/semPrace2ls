/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * API
 * Auto-generated API docs
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AuthControllerConfirmEmailParams,
  BranchDto,
  CreateBranchDto,
  CreateEmployeeDto,
  CreateOwnerDto,
  EmployeeDto,
  LoginDto,
  MeResponseDto,
  OwnerDto,
  RegisterDto
} from './model';

import { customInstance } from './custom-axios';
type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary Register user via Supabase
 */
export const authControllerRegister = (
    registerDto: RegisterDto,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/auth/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: registerDto, signal
    },
      options);
    }
  


export const getAuthControllerRegisterMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerRegister>>, TError,{data: RegisterDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerRegister>>, TError,{data: RegisterDto}, TContext> => {

const mutationKey = ['authControllerRegister'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerRegister>>, {data: RegisterDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerRegister(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerRegisterMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerRegister>>>
    export type AuthControllerRegisterMutationBody = RegisterDto
    export type AuthControllerRegisterMutationError = unknown

    /**
 * @summary Register user via Supabase
 */
export const useAuthControllerRegister = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerRegister>>, TError,{data: RegisterDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof authControllerRegister>>,
        TError,
        {data: RegisterDto},
        TContext
      > => {

      const mutationOptions = getAuthControllerRegisterMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * @summary Login user via Supabase
 */
export const authControllerLogin = (
    loginDto: LoginDto,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginDto, signal
    },
      options);
    }
  


export const getAuthControllerLoginMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError,{data: LoginDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError,{data: LoginDto}, TContext> => {

const mutationKey = ['authControllerLogin'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerLogin>>, {data: LoginDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerLogin(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerLoginMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerLogin>>>
    export type AuthControllerLoginMutationBody = LoginDto
    export type AuthControllerLoginMutationError = unknown

    /**
 * @summary Login user via Supabase
 */
export const useAuthControllerLogin = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError,{data: LoginDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof authControllerLogin>>,
        TError,
        {data: LoginDto},
        TContext
      > => {

      const mutationOptions = getAuthControllerLoginMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * @summary Logout user
 */
export const authControllerLogout = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/auth/logout`, method: 'POST', signal
    },
      options);
    }
  


export const getAuthControllerLogoutMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLogout>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerLogout>>, TError,void, TContext> => {

const mutationKey = ['authControllerLogout'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerLogout>>, void> = () => {
          

          return  authControllerLogout(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerLogoutMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerLogout>>>
    
    export type AuthControllerLogoutMutationError = unknown

    /**
 * @summary Logout user
 */
export const useAuthControllerLogout = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLogout>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof authControllerLogout>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getAuthControllerLogoutMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
export const authControllerConfirmEmail = (
    params: AuthControllerConfirmEmailParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/auth/confirm`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getAuthControllerConfirmEmailQueryKey = (params: AuthControllerConfirmEmailParams,) => {
    return [`/auth/confirm`, ...(params ? [params]: [])] as const;
    }

    
export const getAuthControllerConfirmEmailQueryOptions = <TData = Awaited<ReturnType<typeof authControllerConfirmEmail>>, TError = unknown>(params: AuthControllerConfirmEmailParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof authControllerConfirmEmail>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerConfirmEmailQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerConfirmEmail>>> = ({ signal }) => authControllerConfirmEmail(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof authControllerConfirmEmail>>, TError, TData> & { queryKey: QueryKey }
}

export type AuthControllerConfirmEmailQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerConfirmEmail>>>
export type AuthControllerConfirmEmailQueryError = unknown



export function useAuthControllerConfirmEmail<TData = Awaited<ReturnType<typeof authControllerConfirmEmail>>, TError = unknown>(
 params: AuthControllerConfirmEmailParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof authControllerConfirmEmail>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getAuthControllerConfirmEmailQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const authControllerMe = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<MeResponseDto>(
      {url: `/auth/me`, method: 'GET', signal
    },
      options);
    }
  

export const getAuthControllerMeQueryKey = () => {
    return [`/auth/me`] as const;
    }

    
export const getAuthControllerMeQueryOptions = <TData = Awaited<ReturnType<typeof authControllerMe>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerMe>>> = ({ signal }) => authControllerMe(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData> & { queryKey: QueryKey }
}

export type AuthControllerMeQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerMe>>>
export type AuthControllerMeQueryError = unknown



export function useAuthControllerMe<TData = Awaited<ReturnType<typeof authControllerMe>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getAuthControllerMeQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all Owners
 */
export const ownersControllerGetAll = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/owners`, method: 'GET', signal
    },
      options);
    }
  

export const getOwnersControllerGetAllQueryKey = () => {
    return [`/owners`] as const;
    }

    
export const getOwnersControllerGetAllQueryOptions = <TData = Awaited<ReturnType<typeof ownersControllerGetAll>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof ownersControllerGetAll>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOwnersControllerGetAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ownersControllerGetAll>>> = ({ signal }) => ownersControllerGetAll(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof ownersControllerGetAll>>, TError, TData> & { queryKey: QueryKey }
}

export type OwnersControllerGetAllQueryResult = NonNullable<Awaited<ReturnType<typeof ownersControllerGetAll>>>
export type OwnersControllerGetAllQueryError = unknown


/**
 * @summary Get all Owners
 */

export function useOwnersControllerGetAll<TData = Awaited<ReturnType<typeof ownersControllerGetAll>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof ownersControllerGetAll>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getOwnersControllerGetAllQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create Owner
 */
export const ownersControllerCreate = (
    createOwnerDto: CreateOwnerDto,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<OwnerDto>(
      {url: `/owners`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createOwnerDto, signal
    },
      options);
    }
  


export const getOwnersControllerCreateMutationOptions = <TError = OwnerDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ownersControllerCreate>>, TError,{data: CreateOwnerDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof ownersControllerCreate>>, TError,{data: CreateOwnerDto}, TContext> => {

const mutationKey = ['ownersControllerCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ownersControllerCreate>>, {data: CreateOwnerDto}> = (props) => {
          const {data} = props ?? {};

          return  ownersControllerCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OwnersControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof ownersControllerCreate>>>
    export type OwnersControllerCreateMutationBody = CreateOwnerDto
    export type OwnersControllerCreateMutationError = OwnerDto

    /**
 * @summary Create Owner
 */
export const useOwnersControllerCreate = <TError = OwnerDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ownersControllerCreate>>, TError,{data: CreateOwnerDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof ownersControllerCreate>>,
        TError,
        {data: CreateOwnerDto},
        TContext
      > => {

      const mutationOptions = getOwnersControllerCreateMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * @summary Get Owner by ID
 */
export const ownersControllerGetById = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/owners/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getOwnersControllerGetByIdQueryKey = (id: string,) => {
    return [`/owners/${id}`] as const;
    }

    
export const getOwnersControllerGetByIdQueryOptions = <TData = Awaited<ReturnType<typeof ownersControllerGetById>>, TError = unknown>(id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof ownersControllerGetById>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOwnersControllerGetByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ownersControllerGetById>>> = ({ signal }) => ownersControllerGetById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof ownersControllerGetById>>, TError, TData> & { queryKey: QueryKey }
}

export type OwnersControllerGetByIdQueryResult = NonNullable<Awaited<ReturnType<typeof ownersControllerGetById>>>
export type OwnersControllerGetByIdQueryError = unknown


/**
 * @summary Get Owner by ID
 */

export function useOwnersControllerGetById<TData = Awaited<ReturnType<typeof ownersControllerGetById>>, TError = unknown>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof ownersControllerGetById>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getOwnersControllerGetByIdQueryOptions(id,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Delete Owner by ID
 */
export const ownersControllerDelete = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/owners/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getOwnersControllerDeleteMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ownersControllerDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof ownersControllerDelete>>, TError,{id: string}, TContext> => {

const mutationKey = ['ownersControllerDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ownersControllerDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  ownersControllerDelete(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OwnersControllerDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof ownersControllerDelete>>>
    
    export type OwnersControllerDeleteMutationError = unknown

    /**
 * @summary Delete Owner by ID
 */
export const useOwnersControllerDelete = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ownersControllerDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof ownersControllerDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getOwnersControllerDeleteMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * @summary Get all Owners where user is a member
 */
export const ownersControllerGetByUserId = (
    userId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<OwnerDto[]>(
      {url: `/owners/user/${userId}`, method: 'GET', signal
    },
      options);
    }
  

export const getOwnersControllerGetByUserIdQueryKey = (userId: string,) => {
    return [`/owners/user/${userId}`] as const;
    }

    
export const getOwnersControllerGetByUserIdQueryOptions = <TData = Awaited<ReturnType<typeof ownersControllerGetByUserId>>, TError = OwnerDto[]>(userId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof ownersControllerGetByUserId>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOwnersControllerGetByUserIdQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ownersControllerGetByUserId>>> = ({ signal }) => ownersControllerGetByUserId(userId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof ownersControllerGetByUserId>>, TError, TData> & { queryKey: QueryKey }
}

export type OwnersControllerGetByUserIdQueryResult = NonNullable<Awaited<ReturnType<typeof ownersControllerGetByUserId>>>
export type OwnersControllerGetByUserIdQueryError = OwnerDto[]


/**
 * @summary Get all Owners where user is a member
 */

export function useOwnersControllerGetByUserId<TData = Awaited<ReturnType<typeof ownersControllerGetByUserId>>, TError = OwnerDto[]>(
 userId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof ownersControllerGetByUserId>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getOwnersControllerGetByUserIdQueryOptions(userId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all Branches
 */
export const branchControllerGetAll = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/branch`, method: 'GET', signal
    },
      options);
    }
  

export const getBranchControllerGetAllQueryKey = () => {
    return [`/branch`] as const;
    }

    
export const getBranchControllerGetAllQueryOptions = <TData = Awaited<ReturnType<typeof branchControllerGetAll>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof branchControllerGetAll>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBranchControllerGetAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof branchControllerGetAll>>> = ({ signal }) => branchControllerGetAll(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof branchControllerGetAll>>, TError, TData> & { queryKey: QueryKey }
}

export type BranchControllerGetAllQueryResult = NonNullable<Awaited<ReturnType<typeof branchControllerGetAll>>>
export type BranchControllerGetAllQueryError = unknown


/**
 * @summary Get all Branches
 */

export function useBranchControllerGetAll<TData = Awaited<ReturnType<typeof branchControllerGetAll>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof branchControllerGetAll>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getBranchControllerGetAllQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create Branch
 */
export const branchControllerCreate = (
    createBranchDto: CreateBranchDto,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<BranchDto>(
      {url: `/branch`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createBranchDto, signal
    },
      options);
    }
  


export const getBranchControllerCreateMutationOptions = <TError = BranchDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof branchControllerCreate>>, TError,{data: CreateBranchDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof branchControllerCreate>>, TError,{data: CreateBranchDto}, TContext> => {

const mutationKey = ['branchControllerCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof branchControllerCreate>>, {data: CreateBranchDto}> = (props) => {
          const {data} = props ?? {};

          return  branchControllerCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type BranchControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof branchControllerCreate>>>
    export type BranchControllerCreateMutationBody = CreateBranchDto
    export type BranchControllerCreateMutationError = BranchDto

    /**
 * @summary Create Branch
 */
export const useBranchControllerCreate = <TError = BranchDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof branchControllerCreate>>, TError,{data: CreateBranchDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof branchControllerCreate>>,
        TError,
        {data: CreateBranchDto},
        TContext
      > => {

      const mutationOptions = getBranchControllerCreateMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * @summary Get Branch by ID
 */
export const branchControllerGetById = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/branch/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getBranchControllerGetByIdQueryKey = (id: string,) => {
    return [`/branch/${id}`] as const;
    }

    
export const getBranchControllerGetByIdQueryOptions = <TData = Awaited<ReturnType<typeof branchControllerGetById>>, TError = unknown>(id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof branchControllerGetById>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBranchControllerGetByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof branchControllerGetById>>> = ({ signal }) => branchControllerGetById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof branchControllerGetById>>, TError, TData> & { queryKey: QueryKey }
}

export type BranchControllerGetByIdQueryResult = NonNullable<Awaited<ReturnType<typeof branchControllerGetById>>>
export type BranchControllerGetByIdQueryError = unknown


/**
 * @summary Get Branch by ID
 */

export function useBranchControllerGetById<TData = Awaited<ReturnType<typeof branchControllerGetById>>, TError = unknown>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof branchControllerGetById>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getBranchControllerGetByIdQueryOptions(id,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get All Branches by owner Id
 */
export const branchControllerGetBranchByOwnerId = (
    ownerId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<BranchDto[]>(
      {url: `/branch/owner/${ownerId}`, method: 'GET', signal
    },
      options);
    }
  

export const getBranchControllerGetBranchByOwnerIdQueryKey = (ownerId: string,) => {
    return [`/branch/owner/${ownerId}`] as const;
    }

    
export const getBranchControllerGetBranchByOwnerIdQueryOptions = <TData = Awaited<ReturnType<typeof branchControllerGetBranchByOwnerId>>, TError = BranchDto[]>(ownerId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof branchControllerGetBranchByOwnerId>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getBranchControllerGetBranchByOwnerIdQueryKey(ownerId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof branchControllerGetBranchByOwnerId>>> = ({ signal }) => branchControllerGetBranchByOwnerId(ownerId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(ownerId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof branchControllerGetBranchByOwnerId>>, TError, TData> & { queryKey: QueryKey }
}

export type BranchControllerGetBranchByOwnerIdQueryResult = NonNullable<Awaited<ReturnType<typeof branchControllerGetBranchByOwnerId>>>
export type BranchControllerGetBranchByOwnerIdQueryError = BranchDto[]


/**
 * @summary Get All Branches by owner Id
 */

export function useBranchControllerGetBranchByOwnerId<TData = Awaited<ReturnType<typeof branchControllerGetBranchByOwnerId>>, TError = BranchDto[]>(
 ownerId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof branchControllerGetBranchByOwnerId>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getBranchControllerGetBranchByOwnerIdQueryOptions(ownerId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all Employees
 */
export const employeeControllerGetAll = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/employee`, method: 'GET', signal
    },
      options);
    }
  

export const getEmployeeControllerGetAllQueryKey = () => {
    return [`/employee`] as const;
    }

    
export const getEmployeeControllerGetAllQueryOptions = <TData = Awaited<ReturnType<typeof employeeControllerGetAll>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof employeeControllerGetAll>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEmployeeControllerGetAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof employeeControllerGetAll>>> = ({ signal }) => employeeControllerGetAll(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof employeeControllerGetAll>>, TError, TData> & { queryKey: QueryKey }
}

export type EmployeeControllerGetAllQueryResult = NonNullable<Awaited<ReturnType<typeof employeeControllerGetAll>>>
export type EmployeeControllerGetAllQueryError = unknown


/**
 * @summary Get all Employees
 */

export function useEmployeeControllerGetAll<TData = Awaited<ReturnType<typeof employeeControllerGetAll>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof employeeControllerGetAll>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getEmployeeControllerGetAllQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create employee
 */
export const employeeControllerCreate = (
    createEmployeeDto: CreateEmployeeDto,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<EmployeeDto>(
      {url: `/employee`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createEmployeeDto, signal
    },
      options);
    }
  


export const getEmployeeControllerCreateMutationOptions = <TError = EmployeeDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof employeeControllerCreate>>, TError,{data: CreateEmployeeDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof employeeControllerCreate>>, TError,{data: CreateEmployeeDto}, TContext> => {

const mutationKey = ['employeeControllerCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof employeeControllerCreate>>, {data: CreateEmployeeDto}> = (props) => {
          const {data} = props ?? {};

          return  employeeControllerCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EmployeeControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof employeeControllerCreate>>>
    export type EmployeeControllerCreateMutationBody = CreateEmployeeDto
    export type EmployeeControllerCreateMutationError = EmployeeDto

    /**
 * @summary Create employee
 */
export const useEmployeeControllerCreate = <TError = EmployeeDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof employeeControllerCreate>>, TError,{data: CreateEmployeeDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof employeeControllerCreate>>,
        TError,
        {data: CreateEmployeeDto},
        TContext
      > => {

      const mutationOptions = getEmployeeControllerCreateMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * @summary Get employee by ID
 */
export const employeeControllerGetById = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/employee/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getEmployeeControllerGetByIdQueryKey = (id: string,) => {
    return [`/employee/${id}`] as const;
    }

    
export const getEmployeeControllerGetByIdQueryOptions = <TData = Awaited<ReturnType<typeof employeeControllerGetById>>, TError = unknown>(id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof employeeControllerGetById>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEmployeeControllerGetByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof employeeControllerGetById>>> = ({ signal }) => employeeControllerGetById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof employeeControllerGetById>>, TError, TData> & { queryKey: QueryKey }
}

export type EmployeeControllerGetByIdQueryResult = NonNullable<Awaited<ReturnType<typeof employeeControllerGetById>>>
export type EmployeeControllerGetByIdQueryError = unknown


/**
 * @summary Get employee by ID
 */

export function useEmployeeControllerGetById<TData = Awaited<ReturnType<typeof employeeControllerGetById>>, TError = unknown>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof employeeControllerGetById>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getEmployeeControllerGetByIdQueryOptions(id,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all employees by branch
 */
export const employeeControllerGetByUserId = (
    userId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<OwnerDto[]>(
      {url: `/employee/user/${userId}`, method: 'GET', signal
    },
      options);
    }
  

export const getEmployeeControllerGetByUserIdQueryKey = (userId: string,) => {
    return [`/employee/user/${userId}`] as const;
    }

    
export const getEmployeeControllerGetByUserIdQueryOptions = <TData = Awaited<ReturnType<typeof employeeControllerGetByUserId>>, TError = OwnerDto[]>(userId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof employeeControllerGetByUserId>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getEmployeeControllerGetByUserIdQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof employeeControllerGetByUserId>>> = ({ signal }) => employeeControllerGetByUserId(userId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof employeeControllerGetByUserId>>, TError, TData> & { queryKey: QueryKey }
}

export type EmployeeControllerGetByUserIdQueryResult = NonNullable<Awaited<ReturnType<typeof employeeControllerGetByUserId>>>
export type EmployeeControllerGetByUserIdQueryError = OwnerDto[]


/**
 * @summary Get all employees by branch
 */

export function useEmployeeControllerGetByUserId<TData = Awaited<ReturnType<typeof employeeControllerGetByUserId>>, TError = OwnerDto[]>(
 userId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof employeeControllerGetByUserId>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getEmployeeControllerGetByUserIdQueryOptions(userId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}

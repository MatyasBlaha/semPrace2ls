/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * API
 * Auto-generated API docs
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AuthControllerConfirmEmailParams,
  CreateOwnerDto,
  LoginDto,
  MeResponseDto,
  OwnerDto,
  RegisterDto
} from './model';

import { customInstance } from './custom-axios';
type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * @summary Register user via Supabase
 */
export const authControllerRegister = (
    registerDto: RegisterDto,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/auth/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: registerDto, signal
    },
      options);
    }
  


export const getAuthControllerRegisterMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerRegister>>, TError,{data: RegisterDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerRegister>>, TError,{data: RegisterDto}, TContext> => {

const mutationKey = ['authControllerRegister'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerRegister>>, {data: RegisterDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerRegister(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerRegisterMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerRegister>>>
    export type AuthControllerRegisterMutationBody = RegisterDto
    export type AuthControllerRegisterMutationError = unknown

    /**
 * @summary Register user via Supabase
 */
export const useAuthControllerRegister = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerRegister>>, TError,{data: RegisterDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof authControllerRegister>>,
        TError,
        {data: RegisterDto},
        TContext
      > => {

      const mutationOptions = getAuthControllerRegisterMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * @summary Login user via Supabase
 */
export const authControllerLogin = (
    loginDto: LoginDto,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginDto, signal
    },
      options);
    }
  


export const getAuthControllerLoginMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError,{data: LoginDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError,{data: LoginDto}, TContext> => {

const mutationKey = ['authControllerLogin'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerLogin>>, {data: LoginDto}> = (props) => {
          const {data} = props ?? {};

          return  authControllerLogin(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerLoginMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerLogin>>>
    export type AuthControllerLoginMutationBody = LoginDto
    export type AuthControllerLoginMutationError = unknown

    /**
 * @summary Login user via Supabase
 */
export const useAuthControllerLogin = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError,{data: LoginDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof authControllerLogin>>,
        TError,
        {data: LoginDto},
        TContext
      > => {

      const mutationOptions = getAuthControllerLoginMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * @summary Logout user
 */
export const authControllerLogout = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/auth/logout`, method: 'POST', signal
    },
      options);
    }
  


export const getAuthControllerLogoutMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLogout>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerLogout>>, TError,void, TContext> => {

const mutationKey = ['authControllerLogout'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerLogout>>, void> = () => {
          

          return  authControllerLogout(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerLogoutMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerLogout>>>
    
    export type AuthControllerLogoutMutationError = unknown

    /**
 * @summary Logout user
 */
export const useAuthControllerLogout = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLogout>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof authControllerLogout>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getAuthControllerLogoutMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
export const authControllerConfirmEmail = (
    params: AuthControllerConfirmEmailParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/auth/confirm`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getAuthControllerConfirmEmailQueryKey = (params: AuthControllerConfirmEmailParams,) => {
    return [`/auth/confirm`, ...(params ? [params]: [])] as const;
    }

    
export const getAuthControllerConfirmEmailQueryOptions = <TData = Awaited<ReturnType<typeof authControllerConfirmEmail>>, TError = unknown>(params: AuthControllerConfirmEmailParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof authControllerConfirmEmail>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerConfirmEmailQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerConfirmEmail>>> = ({ signal }) => authControllerConfirmEmail(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof authControllerConfirmEmail>>, TError, TData> & { queryKey: QueryKey }
}

export type AuthControllerConfirmEmailQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerConfirmEmail>>>
export type AuthControllerConfirmEmailQueryError = unknown



export function useAuthControllerConfirmEmail<TData = Awaited<ReturnType<typeof authControllerConfirmEmail>>, TError = unknown>(
 params: AuthControllerConfirmEmailParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof authControllerConfirmEmail>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getAuthControllerConfirmEmailQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const authControllerMe = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<MeResponseDto>(
      {url: `/auth/me`, method: 'GET', signal
    },
      options);
    }
  

export const getAuthControllerMeQueryKey = () => {
    return [`/auth/me`] as const;
    }

    
export const getAuthControllerMeQueryOptions = <TData = Awaited<ReturnType<typeof authControllerMe>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAuthControllerMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof authControllerMe>>> = ({ signal }) => authControllerMe(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData> & { queryKey: QueryKey }
}

export type AuthControllerMeQueryResult = NonNullable<Awaited<ReturnType<typeof authControllerMe>>>
export type AuthControllerMeQueryError = unknown



export function useAuthControllerMe<TData = Awaited<ReturnType<typeof authControllerMe>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof authControllerMe>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getAuthControllerMeQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get all Owners
 */
export const ownersControllerGetAll = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/owners`, method: 'GET', signal
    },
      options);
    }
  

export const getOwnersControllerGetAllQueryKey = () => {
    return [`/owners`] as const;
    }

    
export const getOwnersControllerGetAllQueryOptions = <TData = Awaited<ReturnType<typeof ownersControllerGetAll>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof ownersControllerGetAll>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOwnersControllerGetAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ownersControllerGetAll>>> = ({ signal }) => ownersControllerGetAll(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof ownersControllerGetAll>>, TError, TData> & { queryKey: QueryKey }
}

export type OwnersControllerGetAllQueryResult = NonNullable<Awaited<ReturnType<typeof ownersControllerGetAll>>>
export type OwnersControllerGetAllQueryError = unknown


/**
 * @summary Get all Owners
 */

export function useOwnersControllerGetAll<TData = Awaited<ReturnType<typeof ownersControllerGetAll>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof ownersControllerGetAll>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getOwnersControllerGetAllQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create Owner
 */
export const ownersControllerCreate = (
    createOwnerDto: CreateOwnerDto,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<OwnerDto>(
      {url: `/owners`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createOwnerDto, signal
    },
      options);
    }
  


export const getOwnersControllerCreateMutationOptions = <TError = OwnerDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ownersControllerCreate>>, TError,{data: CreateOwnerDto}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof ownersControllerCreate>>, TError,{data: CreateOwnerDto}, TContext> => {

const mutationKey = ['ownersControllerCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ownersControllerCreate>>, {data: CreateOwnerDto}> = (props) => {
          const {data} = props ?? {};

          return  ownersControllerCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OwnersControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof ownersControllerCreate>>>
    export type OwnersControllerCreateMutationBody = CreateOwnerDto
    export type OwnersControllerCreateMutationError = OwnerDto

    /**
 * @summary Create Owner
 */
export const useOwnersControllerCreate = <TError = OwnerDto,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ownersControllerCreate>>, TError,{data: CreateOwnerDto}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof ownersControllerCreate>>,
        TError,
        {data: CreateOwnerDto},
        TContext
      > => {

      const mutationOptions = getOwnersControllerCreateMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * @summary Get Owner by ID
 */
export const ownersControllerGetById = (
    id: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/owners/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getOwnersControllerGetByIdQueryKey = (id: string,) => {
    return [`/owners/${id}`] as const;
    }

    
export const getOwnersControllerGetByIdQueryOptions = <TData = Awaited<ReturnType<typeof ownersControllerGetById>>, TError = unknown>(id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof ownersControllerGetById>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOwnersControllerGetByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ownersControllerGetById>>> = ({ signal }) => ownersControllerGetById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof ownersControllerGetById>>, TError, TData> & { queryKey: QueryKey }
}

export type OwnersControllerGetByIdQueryResult = NonNullable<Awaited<ReturnType<typeof ownersControllerGetById>>>
export type OwnersControllerGetByIdQueryError = unknown


/**
 * @summary Get Owner by ID
 */

export function useOwnersControllerGetById<TData = Awaited<ReturnType<typeof ownersControllerGetById>>, TError = unknown>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof ownersControllerGetById>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getOwnersControllerGetByIdQueryOptions(id,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Delete Owner by ID
 */
export const ownersControllerDelete = (
    id: string,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/owners/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getOwnersControllerDeleteMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ownersControllerDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof ownersControllerDelete>>, TError,{id: string}, TContext> => {

const mutationKey = ['ownersControllerDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof ownersControllerDelete>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  ownersControllerDelete(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type OwnersControllerDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof ownersControllerDelete>>>
    
    export type OwnersControllerDeleteMutationError = unknown

    /**
 * @summary Delete Owner by ID
 */
export const useOwnersControllerDelete = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof ownersControllerDelete>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 ): UseMutationResult<
        Awaited<ReturnType<typeof ownersControllerDelete>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getOwnersControllerDeleteMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * @summary Get all Owners where user is a member
 */
export const ownersControllerGetByUserId = (
    userId: string,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/owners/user/${userId}`, method: 'GET', signal
    },
      options);
    }
  

export const getOwnersControllerGetByUserIdQueryKey = (userId: string,) => {
    return [`/owners/user/${userId}`] as const;
    }

    
export const getOwnersControllerGetByUserIdQueryOptions = <TData = Awaited<ReturnType<typeof ownersControllerGetByUserId>>, TError = unknown>(userId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof ownersControllerGetByUserId>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getOwnersControllerGetByUserIdQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof ownersControllerGetByUserId>>> = ({ signal }) => ownersControllerGetByUserId(userId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof ownersControllerGetByUserId>>, TError, TData> & { queryKey: QueryKey }
}

export type OwnersControllerGetByUserIdQueryResult = NonNullable<Awaited<ReturnType<typeof ownersControllerGetByUserId>>>
export type OwnersControllerGetByUserIdQueryError = unknown


/**
 * @summary Get all Owners where user is a member
 */

export function useOwnersControllerGetByUserId<TData = Awaited<ReturnType<typeof ownersControllerGetByUserId>>, TError = unknown>(
 userId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof ownersControllerGetByUserId>>, TError, TData>, request?: SecondParameter<typeof customInstance>}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getOwnersControllerGetByUserIdQueryOptions(userId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
